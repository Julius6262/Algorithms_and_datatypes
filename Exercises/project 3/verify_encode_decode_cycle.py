import os
import subprocess
import sys
import filecmp
import time

# --- Configuration ---
ENCODE_PY_SCRIPT = "Encode.py"  # Your Huffman encoder script
DECODE_PY_SCRIPT = "Decode.py"  # Your Huffman decoder script

# Timeout for each step (encode/decode) in seconds
# Adjust if your implementations are slower or files very large
TIMEOUT_DURATION = 240  # 4 minutes per step

# List of original files to test the full cycle on
# Ensure these files are in the same directory as this script
TEST_FILES = [
    "empty.txt",
    "oneByte.txt",
    "same.txt",             # e.g., the 100,000 'a's file
    "KingJamesBible.txt",
    "ScardoviaWiggsiae.dna",
    "DolphinSunset.jpg",
]

# --- Helper Function to run a single file through the cycle ---

def run_full_cycle_test(original_filename, encode_script, decode_script, timeout_duration):
    print(f"\n--- Testing full encode-decode cycle for: '{original_filename}' ---")

    base, orig_ext = os.path.splitext(original_filename)
    # Using distinct suffixes for files generated by this test script
    encoded_filename = f"{base}.encoded_by_test{orig_ext}"
    decoded_filename = f"{base}.decoded_by_test{orig_ext}"

    files_generated_this_test = [] # Keep track of files to clean up for this specific test

    # 1. Check if original file exists
    if not os.path.exists(original_filename):
        print(f"  ERROR: Original file '{original_filename}' not found. Skipping this test.")
        return "skipped_input_missing", files_generated_this_test

    print(f"  Original file size: {os.path.getsize(original_filename)} bytes")

    # --- Encode Step ---
    print(f"  Step 1: Encoding '{original_filename}' to '{encoded_filename}' using '{encode_script}'...")
    command_encode = [sys.executable, encode_script, original_filename, encoded_filename]
    try:
        start_time = time.time()
        process_encode = subprocess.run(command_encode, capture_output=True, text=True, timeout=timeout_duration, check=False)
        print(f"  Encode process completed in {time.time() - start_time:.2f}s.")

        if process_encode.returncode != 0:
            print(f"  ERROR: '{encode_script}' failed during encoding.")
            print(f"  Return code: {process_encode.returncode}")
            if process_encode.stdout and process_encode.stdout.strip():
                print(f"  Encoder Stdout:\n------\n{process_encode.stdout.strip()}\n------")
            if process_encode.stderr and process_encode.stderr.strip():
                print(f"  Encoder Stderr:\n------\n{process_encode.stderr.strip()}\n------")
            if os.path.exists(encoded_filename): files_generated_this_test.append(encoded_filename)
            return "fail_encode", files_generated_this_test

        if not os.path.exists(encoded_filename):
            print(f"  ERROR: Encoded file '{encoded_filename}' was not created by '{encode_script}'.")
            return "fail_encode", files_generated_this_test

        files_generated_this_test.append(encoded_filename)
        print(f"  Encoding successful. Encoded file '{encoded_filename}' size: {os.path.getsize(encoded_filename)} bytes")

    except subprocess.TimeoutExpired:
        print(f"  ERROR: '{encode_script}' timed out (>{timeout_duration}s) during encoding.")
        if os.path.exists(encoded_filename): files_generated_this_test.append(encoded_filename)
        return "fail_encode_timeout", files_generated_this_test
    except Exception as e:
        print(f"  An unexpected error occurred while running '{encode_script}': {e}")
        if os.path.exists(encoded_filename): files_generated_this_test.append(encoded_filename)
        return "fail_encode_exception", files_generated_this_test

    # --- Decode Step ---
    print(f"  Step 2: Decoding '{encoded_filename}' to '{decoded_filename}' using '{decode_script}'...")
    command_decode = [sys.executable, decode_script, encoded_filename, decoded_filename]
    try:
        start_time = time.time()
        process_decode = subprocess.run(command_decode, capture_output=True, text=True, timeout=timeout_duration, check=False)
        print(f"  Decode process completed in {time.time() - start_time:.2f}s.")

        if process_decode.returncode != 0:
            print(f"  ERROR: '{decode_script}' failed during decoding.")
            print(f"  Return code: {process_decode.returncode}")
            if process_decode.stdout and process_decode.stdout.strip():
                print(f"  Decoder Stdout:\n------\n{process_decode.stdout.strip()}\n------")
            if process_decode.stderr and process_decode.stderr.strip():
                print(f"  Decoder Stderr:\n------\n{process_decode.stderr.strip()}\n------")
            if os.path.exists(decoded_filename): files_generated_this_test.append(decoded_filename)
            return "fail_decode", files_generated_this_test

        if not os.path.exists(decoded_filename):
            print(f"  ERROR: Decoded file '{decoded_filename}' was not created by '{decode_script}'.")
            return "fail_decode", files_generated_this_test

        files_generated_this_test.append(decoded_filename)
        print(f"  Decoding successful. Decoded file '{decoded_filename}' size: {os.path.getsize(decoded_filename)} bytes")

    except subprocess.TimeoutExpired:
        print(f"  ERROR: '{decode_script}' timed out (>{timeout_duration}s) during decoding.")
        if os.path.exists(decoded_filename): files_generated_this_test.append(decoded_filename)
        return "fail_decode_timeout", files_generated_this_test
    except Exception as e:
        print(f"  An unexpected error occurred while running '{decode_script}': {e}")
        if os.path.exists(decoded_filename): files_generated_this_test.append(decoded_filename)
        return "fail_decode_exception", files_generated_this_test

    # --- Comparison Step ---
    print(f"  Step 3: Comparing original '{original_filename}' with decoded '{decoded_filename}'...")
    try:
        # shallow=False ensures a byte-by-byte comparison
        are_identical = filecmp.cmp(original_filename, decoded_filename, shallow=False)

        if are_identical:
            print(f"  SUCCESS: Decoded file is identical to the original.")
            return "pass", files_generated_this_test
        else:
            size_orig = os.path.getsize(original_filename)
            size_dec = os.path.getsize(decoded_filename)
            if size_orig != size_dec:
                print(f"  FAILURE: Files are NOT identical. Size mismatch: "
                      f"Original is {size_orig} bytes, Decoded is {size_dec} bytes.")
            else:
                print(f"  FAILURE: Files are NOT identical, but sizes are the same ({size_orig} bytes). "
                      f"Content differs.")
            return "fail_compare_content", files_generated_this_test
    except FileNotFoundError:
        # This should ideally not happen if previous steps created the files
        print(f"  ERROR: One of the files for comparison was not found. "
              f"(Original: {os.path.exists(original_filename)}, Decoded: {os.path.exists(decoded_filename)})")
        return "fail_compare_missing_file", files_generated_this_test
    except Exception as e:
        print(f"  An unexpected error occurred during file comparison: {e}")
        return "fail_compare_exception", files_generated_this_test

# --- Main Execution ---

def main():
    print("Starting verification of Encode-Decode cycle correctness...")
    print("========================================================")
    print(f"Ensure '{ENCODE_PY_SCRIPT}', '{DECODE_PY_SCRIPT}', and all test input files are in this directory:")
    for f_name in TEST_FILES:
        print(f"  - {f_name}")
    print("========================================================")

    # Check for presence of Encode and Decode scripts once
    if not os.path.exists(ENCODE_PY_SCRIPT):
        print(f"FATAL ERROR: '{ENCODE_PY_SCRIPT}' not found. Exiting.")
        sys.exit(1)
    if not os.path.exists(DECODE_PY_SCRIPT):
        print(f"FATAL ERROR: '{DECODE_PY_SCRIPT}' not found. Exiting.")
        sys.exit(1)

    results = {
        "pass": 0, "fail_encode": 0, "fail_encode_timeout": 0, "fail_encode_exception": 0,
        "fail_decode": 0, "fail_decode_timeout": 0, "fail_decode_exception": 0,
        "fail_compare_content": 0, "fail_compare_missing_file": 0, "fail_compare_exception": 0,
        "skipped_input_missing": 0
    }
    all_temp_files_to_clean = set() # Use a set to avoid duplicates

    for filename in TEST_FILES:
        status, temp_files_for_this_run = run_full_cycle_test(filename, ENCODE_PY_SCRIPT, DECODE_PY_SCRIPT, TIMEOUT_DURATION)
        results[status] = results.get(status, 0) + 1
        for temp_file in temp_files_for_this_run:
            all_temp_files_to_clean.add(temp_file)

    print("\n\n--- Encode-Decode Cycle Verification Summary ---")
    total_tests = len(TEST_FILES)
    print(f"Total original files processed: {total_tests}")
    for status_key, count in results.items():
        if count > 0 : # Only print categories that occurred
             print(f"  {status_key.replace('_', ' ').capitalize()}: {count}")

    if results["pass"] == total_tests - results["skipped_input_missing"]:
        if results["skipped_input_missing"] > 0:
            print("\nAll runnable tests passed! Some input files were skipped.")
        else:
            print("\nAll tests passed successfully! Original and decoded files are identical.")
    else:
        print("\nSome tests failed or encountered errors. Please review the output above.")
    print("========================================================")

    # Cleanup
    if all_temp_files_to_clean:
        print("\n--- Cleaning up generated intermediate files ---")
        cleaned_count = 0
        for f_path in all_temp_files_to_clean:
            if os.path.exists(f_path):
                try:
                    os.remove(f_path)
                    print(f"  Removed: {f_path}")
                    cleaned_count +=1
                except OSError as e:
                    print(f"  Error removing '{f_path}': {e}")
        if cleaned_count == 0 and any(os.path.exists(f) for f in all_temp_files_to_clean):
             print("  Note: Some temporary files might still exist if errors occurred before removal or during removal.")
        print("Cleanup complete.")
    else:
        print("\nNo temporary files were marked for cleanup (or no tests fully ran).")


if __name__ == "__main__":
    main()